:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:FHESafeMath: pass:normal[xref:utils.adoc#FHESafeMath[`FHESafeMath`]]
:CheckpointsConfidential: pass:normal[xref:utils.adoc#CheckpointsConfidential[`CheckpointsConfidential`]]
:HandleAccessManager: pass:normal[xref:utils.adoc#HandleAccessManager[`HandleAccessManager`]]

= Utils

[.readme-notice]
NOTE: This document is better viewed at https://docs.openzeppelin.com/confidential-contracts/api/utils

Miscellaneous contracts and libraries containing utility functions you can use to improve security, and ease integrations when working with confidential contracts.

- {FHESafeMath}: Implementation of safe math operations for encrypted values.
- {CheckpointsConfidential}: Implementation of checkpoints for encrypted values.
- {HandleAccessManager}: Minimal contract that adds a function to give allowance to callers for a given ciphertext handle.

== Math

:tryIncrease: pass:normal[xref:#FHESafeMath-tryIncrease-euint64-euint64-[`++tryIncrease++`]]
:tryDecrease: pass:normal[xref:#FHESafeMath-tryDecrease-euint64-euint64-[`++tryDecrease++`]]
:tryAdd: pass:normal[xref:#FHESafeMath-tryAdd-euint64-euint64-[`++tryAdd++`]]
:trySub: pass:normal[xref:#FHESafeMath-trySub-euint64-euint64-[`++trySub++`]]

:tryIncrease-euint64-euint64: pass:normal[xref:#FHESafeMath-tryIncrease-euint64-euint64-[`++tryIncrease++`]]
:tryDecrease-euint64-euint64: pass:normal[xref:#FHESafeMath-tryDecrease-euint64-euint64-[`++tryDecrease++`]]
:tryAdd-euint64-euint64: pass:normal[xref:#FHESafeMath-tryAdd-euint64-euint64-[`++tryAdd++`]]
:trySub-euint64-euint64: pass:normal[xref:#FHESafeMath-trySub-euint64-euint64-[`++trySub++`]]

[.contract]
[[FHESafeMath]]
=== `++FHESafeMath++` link:https://github.com/OpenZeppelin/openzeppelin-confidential-contracts/blob/master/contracts/utils/FHESafeMath.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/confidential-contracts/utils/FHESafeMath.sol";
```

Library providing safe arithmetic operations for encrypted values
to handle potential overflows in FHE operations.

[.contract-index]
.Functions
--
* `++tryIncrease(oldValue, delta)++`
* `++tryDecrease(oldValue, delta)++`
* `++tryAdd(a, b)++`
* `++trySub(a, b)++`

--

[.contract-item]
[[FHESafeMath-tryIncrease-euint64-euint64-]]
==== `[.contract-item-name]#++tryIncrease++#++(euint64 oldValue, euint64 delta) → ebool success, euint64 updated++` [.item-kind]#internal#

Try to increase the encrypted value `oldValue` by `delta`. If the operation is successful,
`success` will be true and `updated` will be the new value. Otherwise, `success` will be false
and `updated` will be the original value.

[.contract-item]
[[FHESafeMath-tryDecrease-euint64-euint64-]]
==== `[.contract-item-name]#++tryDecrease++#++(euint64 oldValue, euint64 delta) → ebool success, euint64 updated++` [.item-kind]#internal#

Try to decrease the encrypted value `oldValue` by `delta`. If the operation is successful,
`success` will be true and `updated` will be the new value. Otherwise, `success` will be false
and `updated` will be the original value.

[.contract-item]
[[FHESafeMath-tryAdd-euint64-euint64-]]
==== `[.contract-item-name]#++tryAdd++#++(euint64 a, euint64 b) → ebool success, euint64 res++` [.item-kind]#internal#

Try to add `a` and `b`. If the operation is successful, `success` will be true and `res`
will be the sum of `a` and `b`. Otherwise, `success` will be false, and `res` will be 0.

[.contract-item]
[[FHESafeMath-trySub-euint64-euint64-]]
==== `[.contract-item-name]#++trySub++#++(euint64 a, euint64 b) → ebool success, euint64 res++` [.item-kind]#internal#

Try to subtract `b` from `a`. If the operation is successful, `success` will be true and `res`
will be `a - b`. Otherwise, `success` will be false, and `res` will be 0.

== Structs

:TraceEuint32: pass:normal[xref:#CheckpointsConfidential-TraceEuint32[`++TraceEuint32++`]]
:push: pass:normal[xref:#CheckpointsConfidential-push-struct-CheckpointsConfidential-TraceEuint32-uint256-euint32-[`++push++`]]
:lowerLookup: pass:normal[xref:#CheckpointsConfidential-lowerLookup-struct-CheckpointsConfidential-TraceEuint32-uint256-[`++lowerLookup++`]]
:upperLookup: pass:normal[xref:#CheckpointsConfidential-upperLookup-struct-CheckpointsConfidential-TraceEuint32-uint256-[`++upperLookup++`]]
:upperLookupRecent: pass:normal[xref:#CheckpointsConfidential-upperLookupRecent-struct-CheckpointsConfidential-TraceEuint32-uint256-[`++upperLookupRecent++`]]
:latest: pass:normal[xref:#CheckpointsConfidential-latest-struct-CheckpointsConfidential-TraceEuint32-[`++latest++`]]
:latestCheckpoint: pass:normal[xref:#CheckpointsConfidential-latestCheckpoint-struct-CheckpointsConfidential-TraceEuint32-[`++latestCheckpoint++`]]
:length: pass:normal[xref:#CheckpointsConfidential-length-struct-CheckpointsConfidential-TraceEuint32-[`++length++`]]
:at: pass:normal[xref:#CheckpointsConfidential-at-struct-CheckpointsConfidential-TraceEuint32-uint32-[`++at++`]]
:TraceEuint64: pass:normal[xref:#CheckpointsConfidential-TraceEuint64[`++TraceEuint64++`]]
:push: pass:normal[xref:#CheckpointsConfidential-push-struct-CheckpointsConfidential-TraceEuint64-uint256-euint64-[`++push++`]]
:lowerLookup: pass:normal[xref:#CheckpointsConfidential-lowerLookup-struct-CheckpointsConfidential-TraceEuint64-uint256-[`++lowerLookup++`]]
:upperLookup: pass:normal[xref:#CheckpointsConfidential-upperLookup-struct-CheckpointsConfidential-TraceEuint64-uint256-[`++upperLookup++`]]
:upperLookupRecent: pass:normal[xref:#CheckpointsConfidential-upperLookupRecent-struct-CheckpointsConfidential-TraceEuint64-uint256-[`++upperLookupRecent++`]]
:latest: pass:normal[xref:#CheckpointsConfidential-latest-struct-CheckpointsConfidential-TraceEuint64-[`++latest++`]]
:latestCheckpoint: pass:normal[xref:#CheckpointsConfidential-latestCheckpoint-struct-CheckpointsConfidential-TraceEuint64-[`++latestCheckpoint++`]]
:length: pass:normal[xref:#CheckpointsConfidential-length-struct-CheckpointsConfidential-TraceEuint64-[`++length++`]]
:at: pass:normal[xref:#CheckpointsConfidential-at-struct-CheckpointsConfidential-TraceEuint64-uint32-[`++at++`]]

:push-struct-CheckpointsConfidential-TraceEuint32-uint256-euint32: pass:normal[xref:#CheckpointsConfidential-push-struct-CheckpointsConfidential-TraceEuint32-uint256-euint32-[`++push++`]]
:lowerLookup-struct-CheckpointsConfidential-TraceEuint32-uint256: pass:normal[xref:#CheckpointsConfidential-lowerLookup-struct-CheckpointsConfidential-TraceEuint32-uint256-[`++lowerLookup++`]]
:upperLookup-struct-CheckpointsConfidential-TraceEuint32-uint256: pass:normal[xref:#CheckpointsConfidential-upperLookup-struct-CheckpointsConfidential-TraceEuint32-uint256-[`++upperLookup++`]]
:upperLookupRecent-struct-CheckpointsConfidential-TraceEuint32-uint256: pass:normal[xref:#CheckpointsConfidential-upperLookupRecent-struct-CheckpointsConfidential-TraceEuint32-uint256-[`++upperLookupRecent++`]]
:latest-struct-CheckpointsConfidential-TraceEuint32: pass:normal[xref:#CheckpointsConfidential-latest-struct-CheckpointsConfidential-TraceEuint32-[`++latest++`]]
:latestCheckpoint-struct-CheckpointsConfidential-TraceEuint32: pass:normal[xref:#CheckpointsConfidential-latestCheckpoint-struct-CheckpointsConfidential-TraceEuint32-[`++latestCheckpoint++`]]
:length-struct-CheckpointsConfidential-TraceEuint32: pass:normal[xref:#CheckpointsConfidential-length-struct-CheckpointsConfidential-TraceEuint32-[`++length++`]]
:at-struct-CheckpointsConfidential-TraceEuint32-uint32: pass:normal[xref:#CheckpointsConfidential-at-struct-CheckpointsConfidential-TraceEuint32-uint32-[`++at++`]]
:push-struct-CheckpointsConfidential-TraceEuint64-uint256-euint64: pass:normal[xref:#CheckpointsConfidential-push-struct-CheckpointsConfidential-TraceEuint64-uint256-euint64-[`++push++`]]
:lowerLookup-struct-CheckpointsConfidential-TraceEuint64-uint256: pass:normal[xref:#CheckpointsConfidential-lowerLookup-struct-CheckpointsConfidential-TraceEuint64-uint256-[`++lowerLookup++`]]
:upperLookup-struct-CheckpointsConfidential-TraceEuint64-uint256: pass:normal[xref:#CheckpointsConfidential-upperLookup-struct-CheckpointsConfidential-TraceEuint64-uint256-[`++upperLookup++`]]
:upperLookupRecent-struct-CheckpointsConfidential-TraceEuint64-uint256: pass:normal[xref:#CheckpointsConfidential-upperLookupRecent-struct-CheckpointsConfidential-TraceEuint64-uint256-[`++upperLookupRecent++`]]
:latest-struct-CheckpointsConfidential-TraceEuint64: pass:normal[xref:#CheckpointsConfidential-latest-struct-CheckpointsConfidential-TraceEuint64-[`++latest++`]]
:latestCheckpoint-struct-CheckpointsConfidential-TraceEuint64: pass:normal[xref:#CheckpointsConfidential-latestCheckpoint-struct-CheckpointsConfidential-TraceEuint64-[`++latestCheckpoint++`]]
:length-struct-CheckpointsConfidential-TraceEuint64: pass:normal[xref:#CheckpointsConfidential-length-struct-CheckpointsConfidential-TraceEuint64-[`++length++`]]
:at-struct-CheckpointsConfidential-TraceEuint64-uint32: pass:normal[xref:#CheckpointsConfidential-at-struct-CheckpointsConfidential-TraceEuint64-uint32-[`++at++`]]

[.contract]
[[CheckpointsConfidential]]
=== `++CheckpointsConfidential++` link:https://github.com/OpenZeppelin/openzeppelin-confidential-contracts/blob/master/contracts/utils/structs/CheckpointsConfidential.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/confidential-contracts/utils/structs/CheckpointsConfidential.sol";
```

This library defines the `Trace*` struct, for checkpointing values as they change at different points in
time, and later looking up past values by block number.

To create a history of checkpoints, define a variable type `CheckpointsConfidential.Trace*` in your contract, and store a new
checkpoint for the current transaction block using the {push} function.

[.contract-index]
.Functions
--
* `++push(self, key, value)++`
* `++lowerLookup(self, key)++`
* `++upperLookup(self, key)++`
* `++upperLookupRecent(self, key)++`
* `++latest(self)++`
* `++latestCheckpoint(self)++`
* `++length(self)++`
* `++at(self, pos)++`
* `++push(self, key, value)++`
* `++lowerLookup(self, key)++`
* `++upperLookup(self, key)++`
* `++upperLookupRecent(self, key)++`
* `++latest(self)++`
* `++latestCheckpoint(self)++`
* `++length(self)++`
* `++at(self, pos)++`

--

[.contract-item]
[[CheckpointsConfidential-push-struct-CheckpointsConfidential-TraceEuint32-uint256-euint32-]]
==== `[.contract-item-name]#++push++#++(struct CheckpointsConfidential.TraceEuint32 self, uint256 key, euint32 value) → euint32 oldValue, euint32 newValue++` [.item-kind]#internal#

Pushes a (`key`, `value`) pair into a TraceEuint32 so that it is stored as the checkpoint.

Returns previous value and new value.

IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint256).max` key set will disable the
library.

[.contract-item]
[[CheckpointsConfidential-lowerLookup-struct-CheckpointsConfidential-TraceEuint32-uint256-]]
==== `[.contract-item-name]#++lowerLookup++#++(struct CheckpointsConfidential.TraceEuint32 self, uint256 key) → euint32++` [.item-kind]#internal#

Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if
there is none.

[.contract-item]
[[CheckpointsConfidential-upperLookup-struct-CheckpointsConfidential-TraceEuint32-uint256-]]
==== `[.contract-item-name]#++upperLookup++#++(struct CheckpointsConfidential.TraceEuint32 self, uint256 key) → euint32++` [.item-kind]#internal#

Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero
if there is none.

[.contract-item]
[[CheckpointsConfidential-upperLookupRecent-struct-CheckpointsConfidential-TraceEuint32-uint256-]]
==== `[.contract-item-name]#++upperLookupRecent++#++(struct CheckpointsConfidential.TraceEuint32 self, uint256 key) → euint32++` [.item-kind]#internal#

Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero
if there is none.

NOTE: This is a variant of {upperLookup} that is optimized to find "recent" checkpoint (checkpoints with high
keys).

[.contract-item]
[[CheckpointsConfidential-latest-struct-CheckpointsConfidential-TraceEuint32-]]
==== `[.contract-item-name]#++latest++#++(struct CheckpointsConfidential.TraceEuint32 self) → euint32++` [.item-kind]#internal#

Returns the value in the most recent checkpoint, or zero if there are no checkpoints.

[.contract-item]
[[CheckpointsConfidential-latestCheckpoint-struct-CheckpointsConfidential-TraceEuint32-]]
==== `[.contract-item-name]#++latestCheckpoint++#++(struct CheckpointsConfidential.TraceEuint32 self) → bool exists, uint256 key, euint32 value++` [.item-kind]#internal#

Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value
in the most recent checkpoint.

[.contract-item]
[[CheckpointsConfidential-length-struct-CheckpointsConfidential-TraceEuint32-]]
==== `[.contract-item-name]#++length++#++(struct CheckpointsConfidential.TraceEuint32 self) → uint256++` [.item-kind]#internal#

Returns the number of checkpoints.

[.contract-item]
[[CheckpointsConfidential-at-struct-CheckpointsConfidential-TraceEuint32-uint32-]]
==== `[.contract-item-name]#++at++#++(struct CheckpointsConfidential.TraceEuint32 self, uint32 pos) → uint256 key, euint32 value++` [.item-kind]#internal#

Returns checkpoint at given position.

[.contract-item]
[[CheckpointsConfidential-push-struct-CheckpointsConfidential-TraceEuint64-uint256-euint64-]]
==== `[.contract-item-name]#++push++#++(struct CheckpointsConfidential.TraceEuint64 self, uint256 key, euint64 value) → euint64 oldValue, euint64 newValue++` [.item-kind]#internal#

Pushes a (`key`, `value`) pair into a TraceEuint64 so that it is stored as the checkpoint.

Returns previous value and new value.

IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint256).max` key set will disable the
library.

[.contract-item]
[[CheckpointsConfidential-lowerLookup-struct-CheckpointsConfidential-TraceEuint64-uint256-]]
==== `[.contract-item-name]#++lowerLookup++#++(struct CheckpointsConfidential.TraceEuint64 self, uint256 key) → euint64++` [.item-kind]#internal#

Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if
there is none.

[.contract-item]
[[CheckpointsConfidential-upperLookup-struct-CheckpointsConfidential-TraceEuint64-uint256-]]
==== `[.contract-item-name]#++upperLookup++#++(struct CheckpointsConfidential.TraceEuint64 self, uint256 key) → euint64++` [.item-kind]#internal#

Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero
if there is none.

[.contract-item]
[[CheckpointsConfidential-upperLookupRecent-struct-CheckpointsConfidential-TraceEuint64-uint256-]]
==== `[.contract-item-name]#++upperLookupRecent++#++(struct CheckpointsConfidential.TraceEuint64 self, uint256 key) → euint64++` [.item-kind]#internal#

Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero
if there is none.

NOTE: This is a variant of {upperLookup} that is optimized to find "recent" checkpoint (checkpoints with high
keys).

[.contract-item]
[[CheckpointsConfidential-latest-struct-CheckpointsConfidential-TraceEuint64-]]
==== `[.contract-item-name]#++latest++#++(struct CheckpointsConfidential.TraceEuint64 self) → euint64++` [.item-kind]#internal#

Returns the value in the most recent checkpoint, or zero if there are no checkpoints.

[.contract-item]
[[CheckpointsConfidential-latestCheckpoint-struct-CheckpointsConfidential-TraceEuint64-]]
==== `[.contract-item-name]#++latestCheckpoint++#++(struct CheckpointsConfidential.TraceEuint64 self) → bool exists, uint256 key, euint64 value++` [.item-kind]#internal#

Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value
in the most recent checkpoint.

[.contract-item]
[[CheckpointsConfidential-length-struct-CheckpointsConfidential-TraceEuint64-]]
==== `[.contract-item-name]#++length++#++(struct CheckpointsConfidential.TraceEuint64 self) → uint256++` [.item-kind]#internal#

Returns the number of checkpoints.

[.contract-item]
[[CheckpointsConfidential-at-struct-CheckpointsConfidential-TraceEuint64-uint32-]]
==== `[.contract-item-name]#++at++#++(struct CheckpointsConfidential.TraceEuint64 self, uint32 pos) → uint256 key, euint64 value++` [.item-kind]#internal#

Returns checkpoint at given position.

== Other
:getHandleAllowance: pass:normal[xref:#HandleAccessManager-getHandleAllowance-bytes32-address-bool-[`++getHandleAllowance++`]]
:_validateHandleAllowance: pass:normal[xref:#HandleAccessManager-_validateHandleAllowance-bytes32-[`++_validateHandleAllowance++`]]

:getHandleAllowance-bytes32-address-bool: pass:normal[xref:#HandleAccessManager-getHandleAllowance-bytes32-address-bool-[`++getHandleAllowance++`]]
:_validateHandleAllowance-bytes32: pass:normal[xref:#HandleAccessManager-_validateHandleAllowance-bytes32-[`++_validateHandleAllowance++`]]

[.contract]
[[HandleAccessManager]]
=== `++HandleAccessManager++` link:https://github.com/OpenZeppelin/openzeppelin-confidential-contracts/blob/master/contracts/utils/HandleAccessManager.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@openzeppelin/confidential-contracts/utils/HandleAccessManager.sol";
```

[.contract-index]
.Functions
--
* `++getHandleAllowance(handle, account, persistent)++`
* `++_validateHandleAllowance(handle)++`

--

[.contract-item]
[[HandleAccessManager-getHandleAllowance-bytes32-address-bool-]]
==== `[.contract-item-name]#++getHandleAllowance++#++(bytes32 handle, address account, bool persistent)++` [.item-kind]#public#

Get handle access for the given handle `handle`. Access will be given to the
account `account` with the given persistence flag.

NOTE: This function call is gated by `msg.sender` and validated by the
{_validateHandleAllowance} function.

[.contract-item]
[[HandleAccessManager-_validateHandleAllowance-bytes32-]]
==== `[.contract-item-name]#++_validateHandleAllowance++#++(bytes32 handle)++` [.item-kind]#internal#

Unimplemented function that must revert if the message sender is not allowed to call
{getHandleAllowance} for the given handle.

